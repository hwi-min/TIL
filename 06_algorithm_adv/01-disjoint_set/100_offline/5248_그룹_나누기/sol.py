import sys
sys.stdin = open('input.txt')

def find_set(x):
    if arr[x] != x: # 내가 루트가 아니면
        # 경로 평탄화
        arr[x] = find_set(arr[x])
    return arr[x]

def union(x, y):
    # 그런데 두 집합을 하나의 집합으로 만든다고 할때...
    # 그냥 합쳐버리면 곤란할 듯 하다...
    root_x = find_set(x)
    root_y = find_set(y)
    # 경로 평탄화에 대한 이야기를 하기 전에...
    # 우리는... 누구의 부모 정보를 바꿔야 하는가도 생각해 보기
    if root_x != root_y:
        arr[root_y] = root_x

'''
# 첫 줄에 테스트 케이스의 개수가 주어지고,
다음 줄부터 테스트 케이스 별로 첫 줄에 N과 M, 
다음 줄에 M 쌍의 번호가 주어진다. 2<=N<=100, 1<=M<=100
'''
T = int(input())
for tc in range(1, T+1):
    # 전체 노드의 수 N, 간선의 개수 M
    N, M = map(int, input().split())
    # 간선 정보 M개
    data = list(map(int, input().split()))
    '''
        지금까지는 N개의 원소 정보가 주어지면
        이 N개의 원소를 일단 배열에 전부 순차적으로 집어넣고,
        그 인덱스를 원소의 위치로 하는
        1개의 트리, 혹은 1개의 그래프 형식으로 활용하고 있었다.
        따라서, 주어지는 간선 정보는 
        내가 위에서 만든 트리와 그래프의 "모든 원소들" 을 연결짓는 형태였다
        면
        이제부터는 아닐 수도 있다.
        N개의 원소 정보를 담아둔 배열 하나가
        1개의 트리 혹은 1개의 그래프가 아니라, 
        다수의 트리, 다수의 그래프 형태일 수도 있다!
        (물론, 서로소 집합 형태로 나타낼때는 모두 트리형태가 된다.)
        간선 정보 만으로는 도달 할 수 없는 원소가 있을 수도 있으니
        주어진 edges (간선 정보)가 모든 노드에 대한 정보라고 생각하지 말자.
            매번 매 평가마다 입력 조건, 제약사항을 잘 보라고 말씀드리지만...
            사람은 망각의 동물, 같은 실수를 반복하는 인간이라...
            또.... 또.... 제약조건 놓치고, 입력값 크기 놓치고... 그러지말자!   
    '''
    # 0번 노드를 사용하지 않는다
    # 왜 안쓰냐면... 문제에서 1번 학생이 1번이라고 나와서!
    # 각자 일단 조가 없는 상태로 배열에 담아보자.
    arr = [i for i in range(N+1)]
    # print(arr)  # 독립된 학생들에 대한 정보 모아두기
    '''
        간선 정보를 토대로... 각 학생들은 하나의 세트로 묶어버리기
        예를들어, 간선이 2개 있다. -> data는? [1, 2, 3, 4] 와 같이 4개의 원소가있다.
        간선이 2개 -> 노드가 4개 (중복될 수도 있음)
        0 1 2 3
        1 2 3 4
        시작노드 종료 노드가 아래처럼 주어진다.
        (0번 1번), (2번 3번)
        이걸 어떻게 반복해서 idx를 얻어낼 수 있을까?
        0, 2, 4, 6, 8, 10, 12.... 2step씩 건너 띄어서 얻을 수 있다.   
        시작 노드가 idx
        도착 노드가 idx + 1     
    '''
    for idx in range(0, M*2, 2):    # 간선이 2개 -> 노드가 4개
        start_node = data[idx]
        end_node = data[idx+1]
        union(start_node, end_node)

    '''
        모든 union을 마쳐도, 여전히 모두가 루트를 바라보고 있지는 않다.
        왜 모두가 루트를 바라봐야하나??
        우리는 arr에 들어있는 정보를 토대로, 집합이 몇개가 있는지 세고 싶으니까!
        3번 tc에서 4 5 4 6 7 4 라고 하는 간선정보가
        union을 다해도, 5랑 6은 4번을 대표자로,
        정작 4는 7을 대표자로 보고 있어서, 집합이 다른것처럼 보이게 나온다.
    '''
    # 그래서 모든 노드에 대해서 경로 압축
    for i in range(1, N+1):
        find_set(i) # 진짜 대표자가 누군지 찾도록 한다.
    # print(arr)  # [0, 1, 2, 2, 7, 7, 7, 7]
    # print(N, M, data)
    # 파이썬은 형변환 자유롭다.
    # 0번은 안쓰기로 했으니, 대표자가 몇개인지만 세면된다.
    print(f'#{tc} {len(set(arr)) -1}')